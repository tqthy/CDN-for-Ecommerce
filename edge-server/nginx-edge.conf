worker_processes auto;

# Enables the use of JIT for regular expressions to speed-up their processing.
pcre_jit on;

events {
    worker_connections 1024;
}


http {
    # Use Docker's internal DNS resolver
    resolver 127.0.0.11 valid=30s; 

    include       mime.types;
    default_type  application/octet-stream;

    error_log /logs/error.log debug;

    
    include generic_conf/setup_cache.conf;

    proxy_temp_path     /var/run/openresty/nginx-proxy;
    fastcgi_temp_path   /var/run/openresty/nginx-fastcgi;
    uwsgi_temp_path     /var/run/openresty/nginx-uwsgi;
    scgi_temp_path      /var/run/openresty/nginx-scgi;

    sendfile    on;

    keepalive_timeout   65;

    lua_shared_dict cdn_tasks 10m;

    init_worker_by_lua_block {
        local redis_subscribe = require "/usr/local/openresty/nginx/conf/lua/redis-subscribe";
        redis_subscribe.start()
    }

    upstream origin {
      server origin:3000;
    }
    upstream storage {
      server storage:9000;
    }

    server {
        listen 80;

        location /download {
            include generic_conf/define_cache.conf;
            set $cache_key "";
            if ($uri ~ /([^/]+)$) {
                set $cache_key $1;
            }
            # Use the extracted value as the cache key
            proxy_cache_key $cache_key;
            # modify the request URI to remove the /download prefix
            rewrite ^/download/(.*)$ /$1 break;
            proxy_pass http://storage;
            add_header X-Edge Server;
        }

            # Endpoint to process queued tasks
        location /process-cache {
            content_by_lua_block {
                local cdn_tasks = ngx.shared.cdn_tasks
                local task = cdn_tasks:rpop("tasks")

                while task do
                    local cjson = require "cjson"
                    local success, data = pcall(cjson.decode, task)

                    if success and data.bucket and data.key then
                        local url = "/download/" .. data.bucket .. "/" .. data.key
                        ngx.log(ngx.INFO, "Processing cache for: ", url)

                        local res = ngx.location.capture(url, { method = ngx.HTTP_GET })
                        if res.status == ngx.HTTP_OK then
                            ngx.log(ngx.INFO, "File cached successfully: ", data.key)
                        else
                            ngx.log(ngx.ERR, "Failed to cache file: ", data.key)
                        end
                    else
                        ngx.log(ngx.ERR, "Invalid task data: ", task)
                    end

                    task = cdn_tasks:rpop("tasks") -- Fetch next task
                end

                ngx.say("Cache tasks processed")
            }
        }

        location /api/file/upload {
            proxy_pass http://origin;
        }

        location ~ ^/api/file/download/([^/]+\.[a-zA-Z0-9]+)$ {
            include generic_conf/define_cache.conf;
            set $cache_key "";
            if ($uri ~ /([^/]+)$) {
                set $cache_key $1;
            }
            # Use the extracted value as the cache key
            proxy_cache_key $cache_key;
            proxy_pass http://origin;
            add_header X-Edge Server;
        }

        location / {
            return 404;
        }


        # location ~ ^/api(/|$) {
        #     include generic_conf/define_cache.conf;
        #     proxy_pass http://origin;
        #     add_header X-Edge Server;
        # }
    }


    # include generic_conf/vts_setup.conf;
    # js_path "njs/";
    # js_import example from example.js;
}